Chapter 1 - DNA Replication.
- Begins in the Origin of Replication - OriC

Why is it important to know the OriC? - When we do genetic manipulations, we need to ensure that the OriC remains intact
so that the cell can continue to replicate without a problem.

How do we find the OriC purely computationally? - This is rather hard. If we were doing it the biologist way, we would cut off
parts of the genome and then check if the cells replicate. If they did not, we possibly removed the OriC. As a computer scientist,
this is a little bit harder to achieve. We know that protein named DnaA initiates the replication when it binds to one or multiple
boxes of DNA called DnaA boxes. Why multiple? Well if a mutation occurs, then having other undamaged copies will ensure that 
replication can continue. They hold the same DNA transcripts. The question is, can we find something in the genome that stands
out?

PROBLEM: Here we have our first problem, counting K-mers. We try to find how many times a string is found in a block of text.
Be careful, the strings may overlap! As such we need to use a sliding window technique.

PROBLEM: The second problem appears almost immediately. Sure, we found the frequency of a specific K-mer, but what if we don't know
what to look for? Could we possibly search for the frequency of all K-mers? Sure we can. We can do this by looping through the text
once and saving each value in a dictionary/map. At the end simply filter for the ones with the highest count.

DnaA boxes are usually 9 nucleotides long. This has been declared experimentally. When using our program, we can find that some
long k-mers appear relatively frequently, despite that being statistically unlikely. As such, that means that they must hold some
genetic value and are worth preserving - DnaA box. It turns out that there are multiple K-mers but they are somewhat similar...
some are reverse compliments of others! 

DNA strands and their compliments are always read in 5 -> 3 direction ;).

PROBLEM: Some strands have reverse complements. The DnaA protein does not care if it binds to the DnaA box or its reverse complement
(also considered a DnaA box). Those happen due to the replication of the DNA and the existence of 2 strands, going
in separate directions. Thus we need to find the most common occurrences of a k-mer in a string and then find the reverse complement.

PROBLEM: From here we may deduce that we have found the OriC and that those dna k-mers are the DnaA boxes. That may be so, but what 
if those statistically unreasonable k-mers appear rather frequently throughout the whole genome? Afterall, DnaA boxes should be found
only at the OriC site. We have to check the whole genome and check where those k-mers occur. If we are correct, we will see a clump
of such k-mers at our OriC region and an absence everywhere else.

Checking the Vibrio Cholerae genome returns the following locations: 60039 98409 129189 152283 152354 152411 163207 197028 200160
 357976 376771 392723 532935 600085 622755 1065555

We can deduce that most likely, the bacteria has 3 or 2 OriC points. Between 150 000 - 163 000, 35 000 - 393 000 and the last one
around the 600 000 - 623 000. After doing the same with the reverse compliment, we find it at around 150 000 - 152 000. As such,
we can be fairly certain that this is an OriC and it's DnaA box. Is it the same for all bacterial genomes? Of course not. They
have different Dna A boxes, we confirm that after doing the same experiment with different genomes.

PROBLEM: We have a new genome and we need to find the OriC and the DnaA boxes. We know that we need to find some k-mers that clump 
together in a space. We do not know how long they are, but we can try to guess, maybe around 9 bases. So let us try to find all 
k-mers that clump together in a specific range. The OriC is usually around 500 bases big, so we will choose to search for a clump of
k-mers every 500 bases of our DNA strand.





Chapter 2: - DNA Replication in more detail.

4 - DNA Polymerases replicate the chromosome. 2 for each strand, 1 in each direction.
To start, they need a primer. They then copy the chromosome until they reach the terminus point.

What this means is that the circular bacterial chromosome is replicated in 2 directions.
Two helicases open the chromosome and one goes right, the other goes left. Then 4 DNA Polymerases
start working, 2 in each direction. That ultimately results in 2 new chromosomes, each of which has its 
one half created by okazaki fragments, the other - by the leading strand.

DNA Polymerase is UNIDIRECTIONAL, it can only copy DNA in one direction, namely - 3 -> 5 instead of the
5 -> 3 direction known up to this point.

Forward half strands - 5 -> 3 direction. (Okazaki Fragments) - Lagging strand.
Reverse half strands - 3 -> 5 direction. (Normal replication.) - Leading strand.

(This is why we need forward and reverse primers to perform PCR.)

Okazaki fragments need to wait for the fork to open, then they need to stick a primer and build
backwards. That happens multiple times. DNA Ligase sews the gaps between the Okazaki Fragments, not
at the very end, but during the process.

Helicase starts the DNA unwinding.
Due to the unwinding, torsional stress occurs.
DNA Topoisomerase 1 and 2 relieve the torsional stress but cutting the stressed parts.
Primase adds an RNA primer to the opened DNA strand.
DNA Polymerase binds to the primer and adds the bases.
DNA Ligase fuses the Okazaki Fragments from time to time.

Semiconservative - one old strand and one new strand!

Now something interesting!
Starting from Terminus and going to direction of OriC (reverse way) - high Cytosine count in fragments!
Above 25%. But low Guanine frequency! Below 25%! Lagging strand.

Starting from OriC and going to direction of Terminus (forward way) - low Cytosine count in fragments!
Below 25%. But high Guanine frequency! Above 25%! Leading strand.

So lagging strand has high Cytosine and low Guanine,
while leading strand has high Guanine and low Cytosine!

This is called the skew problem and is believed to be caused by the higher mutation rate of the lagging
strand. (Which is also disputed, since some experiments determine a lower mutation count on the lagging
strand!)

Basically lagging strand has a higher Cytosine and Adenine count, whereas the leading strand has a higher
Guanin and Thymine count!

We can use this to "walk" along the DNA strand and check when the Cytosine content drops and the Guanine 
content rises. At this point, we can conclude that we have found the OriC! Alternatively, we can find the 
Terminus by checking when the Guanine content drops and the Cytosine begins to rise!

Why does that happen? Deamination!
A DNA Helix is stable, because it is composed of 2 strands that hold each other through the H-bounds.
An unwinded DNA Helix is in comparison, highly unstable and prone to mutations! What this means is that
the longer a DNA strand remains unwinded, the more it could mutate. Well, which DNA strand remains unwinded
for a longer time, the leading or the lagging? The lagging, of course. Since it has to wait for the Okazaki
fragments to be built. This results in Cytosine mutating to Thymine through Deamination. That then results
in a lower Guanine rate on the opposite strand as well since a GC pair will mutate to a TA pair.

Difference between total amount of guanine and cytosine on leading strand is negative. On lagging strand -
its positive.

(Lagging has less C, leading has more C)

PROBLEM: Starting at a random spot in the genome and walking along the base pairs, we can compute the 
skew. We will see that at a certain point, the skew rises and at a different, it falls. The skew maximum
is attained at the highest point where G content is at its maximum and then C content begins to increase.
That is the Terminus. The skew minimum is where the C content is at its maximum and the G content begins 
to increase. That is...the OriC! Find the minimum skew, the OriC!

Good, we successfully found the OriC! Now let us check for 9-mers to locate the DnaA boxes! Aaand...
there are no 9-mers. Ok, what now? Let's go back to the E.coli genome where we searched for DnaA boxes.
We can see some 9-mers and what is that? Another 9-mer that is equal to the rest apart for 1 letter? This
is statistically improbable. Maybe it was a complete 9-mer but mutated? This does not bother us, since we
know that DnaA protein can bind to an incomplete DnaA box. So it actually makes sense.

Those incomplete DnaA boxes, can also be seen as mismatches to a complete DnaA box. How much a complete
to an incomplete box differs, that is called the Hamming distance.

PROBLEM: Hamming Distance - find how much 2 strings differ from each other.

PROBLEM: Approximate Pattern Matching - We can search for a K-mer in a string and allow for a certain
amount of errors. For example, we may search for 9 - mer but say that up to 3 bases that mismatch are still
acceptable and the k-mer is to be counted even if not an exact match. This is so, since DnaA can bind even
to an incomplete DnaA box. That means that even an incomplete but fairly similar 9-mer should not be discarded.

Good, we are able to find the positions and count of all k-mers that have a tolerable rate of Hamming Distance
error. But what if we want to find the most freuent k-mers with that Hamming Distance?

PROBLEM: Most Freuqent K-mer With Mismatch - Find the most freuquent k-mers in the DNA with an 
acceptable Hamming Distance. We do that the naive way, by going through the text and adding each k-mer
to a map. Then checking each k-mer in the map against each other and find which have a tolerable hamming 
distance. This is quite inefficient though. Not only that, it will not give us any potential mutated k-mers
that may be encountered! To correctly solve this question, we need to generate the neighbours of a k-mer
and then check the hamming distance against each neighbour.

What is the importance of a Reverse Complementary strand in Biology? Well, take for example the circular
bacterial chromosome. Now, since DNA is semiconservative, we know that one strand will always be used as 
a template. The 2 strands are not equal, but reverse complementray. (A - T) etc. So if we take and analyze
just one strand, we may miss some interesting insights. For that purpose, we need to analyze both the strand
we are given and its reverse complementary strand. Alternatively, we may want to just look for instances
of the reverse complement of the pattern and where it may appear. Since having a repeated 9-mer is rare, but
having a repeated reverse complement of the same k-mer? Ultra rare.

PROBLEM: Most Frequent K-mer with Mismatch and the reverse complement of said K-mer with mismatch.

How would you find DnaA boxes in new bacteria, now that you have this knowledge?

I would first search for the position where the skew attains a minimum.
This will direct me to the position of the OriC. I will then confirm through biological methods
that the region is indeed the OriC. (Removing the DNA region and checking for bacterial reprocution).
After being sure that the region I am in is the OriC, I will search for frequent k-mers
and their reverse complementary strings with a length of 8 to 10 and hamming distance of 3.
I will then compare the results for 8-mers, 9-mers and 10-mers with each other and then the 9-mers
with the 9-mers of different bacteria. Hopefully this will be enough to
notice plenty of similarties in the 9-mers and conclude of the existence of a potential Dna A box.


Now we try to find a DNA A box in Salmonella Enterica!

Why does DNA Polymerase work just in 1 direction? - https://www.youtube.com/watch?v=y4hKibS2fAo
But basically, if you add a new nucleotide, in the correct direction, the phosphate groups are near to the
sugar part and they fuse without need of much energy. If you go the other way around, the first time you
are adding a base, the sugar part will face a phosphate group which has already lost its other 2 phosphates.
That means that the energy needed for the reaction to occur will be very very high. Once the first base
is there though, you could proceed normally. Due to the first step, the DNA Polymerase works in only one
direction!






Chapter 3: - Hunting for Regulatory Motifs

- Regulatory Motifs are pieces of DNA that regulate the expression of certain genes.

Let us take a look at the regulatory systems in plants since they are very, very important.
3 Genes call all the shots - CCA1, LCY and TOC1

TOC1 promotes expression of CCA1 and LCY, while the other 2 repress expression of TOC1.
This results in a negative feedback loop, where more TOC1 means more CCA1 and LCY which means
less TOC1. Light increases production of CCA1 and LCY which repress TOC1. When there is no light,
TOC1 can be expressed which in turn will lead to possibility for expression of CCA1 and LCY when there
is sunlight afterwards.

DSPS - Delayed sleep phase syndrom - malfunction of the circadian rythm due to a genetic modification.

Transcription factors - proteins that regulate the expression of genes.
They bind to a short piece of DNA (regulatory motif) a little stretch before the start of the 
gene in the DNA. - called upstream site.

Regulatory motifs are highly conserved between species, unfortunately some mutations do occur which do not
stop the transcription factors from binding.

How do we find those motifs without knowing what they look like?
Can we use the algorithm for finding DnaA boxes? 

Sure we could, we could take 10 genomes and apply the frequent words problem to a concatenated version
of this genome. This will return the most common string among all 10. But what if this most common string is
actually allowed to mutate a little between all of these genomes? Suddenly, we have 10 different versions 
and not 1 most common string. Maybe we can use the frequent words with mismatches? Sure, but the data 
suddenly becomes huge and unfeasible to compute. Not only that, the frequent words with mismatches solution
caters to an entirely different problem. When we were searching for DNA A boxes, what was the assumption?
We are saerching for clumps of boxes within a small region DNA. Here, that is no longer the case. We are
now searching for one occurence of a specific motif within multiple DNA strands, that is highly conserved.

PROBLEM: Motif finding - Brute Force - Find a K-mer that appears in each DNA string with at most d mismatches.

Good, we managed to solve the motif finding problem successfully by brute forcing it. Unfortunately, 
this simply wouldn't work with real genomes and will be highly impractical. Sure, this algorithm would 
translate well in a multicore environment and maybe even be portable to GPUs, but creating a more efficient
algorithm is the correct way to go. 

We could try to identify the 2 most similar K-mers between each pair of strings in the DNA?
Sure, what about these:
AgAAgAAAGGttGGG
|| || | || |  
cAAtAAAAcGGGGcG

Fairly similar, yet each has mutated 4 times. Unfortunately for us, the mutations are different and in total,
despite the 2 strings having the same origin, they are at a hamming distance of 8 instead of 4! Worst case
scenario! What do we do?

We implement scoring matrices and concensus strings!

What is the problem with the brute force approach? It expects that all 10 DNA strands have a copy of the 
regulatory motif, otherwise the neighbour isn't counted at all. Unfortunately for us, not all copies of 
genes will have the binding site for the regulatory motif. That doesn't mean that it doesn't exist, it 
simply means that we had a bad draw of the dna strands. It may be present in some and in some not!
Could we not add some hamming distance for genes as well? If it doesn't appear in 10% of genes but does in
90%, then all good, right? Well, maybe. But we could also just create a scoring function. That function
would score individual instances of a motif to how close it resembles an "ideal" version. We don't know
this "ideal" string though...So we take a k-mer from each string and we score the k-mers according to how
similar they are to each other.

We take a k-mer from each strand and we put them in a matrix.
Then we check the columns and we find the most frequent nucleotide (ATGC) for each column.
If the occurences are the same, we arbitrarily choose one. Each small letter nucleotide adds 1 point.
The goal is to select the most conserved motif matrix, that with the lowest score.
accG
atTG
GtTG
GATG
GATG

score of this matrix is 6

Afterwards we create a profile matrix that looks like that:

A 0.4
C 0
G 0.6
T 0 

It shows the percentage of ACGT at each col of the matrix. The cols add up to 1.

Finally we form a concensus string from the most popular letters of each column in the matrix.
This concensus matrix provides an ideal candidate of our regulatory profile. 

We may have a column that has 6Cs and 4As, and another, with 6Cs 2As and 2Ts. Does it make sense
to score them the same, since both of them have 6 Cs? Well, no, since the 6C, 4A column is more conserved.
In reality, some regulatory motifs have a few spots that are highly conserved (just 1 nucleotide) and some
that are weakly conserved (either A or T for example). This means that if we encounter a highly conserved 
point, we should give full score, weakly conserved point should give lower score if either of the bases are
in the conserved range (either A or T - for example) or lowest if it is a completely random mutation.

For many biological motifs, certain positions feature two nucleotides with roughly the same ability to bind to a transcription factor.
 For example, the sixteen nucleotide-long CSRE transcription factor binding site in the yeast species S. cerevisiae
 consists of five strongly conserved positions (1, 8, 9, 12, and 13) in addition to eleven weakly conserved positions,
 each of which features two nucleotides with similar frequencies (see figure below).



Following this example, a more appropriate representation of the consensus string TCGGGGATTTCC for the NF-κB binding sites
 should include viable alternatives to the most popular nucleotides in each column. For example, nucleotides with frequencies equal
 to or exceeding 0.4. In this sense, the last column (6 C, 4 T) in the NF-κB motif matrix (reproduced below) is “more conserved”
 than the 2nd column (6 C, 2 A, 2 T) and should receive a lower score.

We can use entropy for our scoring function: H = -1 * (p1 logs(1/p1) + p2 logs(1/p2) + ⋯ + pk logs(1/pk)).

The lower the entropy, the more conserved our DNA strings are.
Note: Technically, log2(0) is undefined, but in the computation of entropy, we assume that 0 · log2(0) is equal to 0.

Now we can formulate our problem. Given a set of strings, find the one string which has the lowest score among them all.

If we do this column by column, we encounter a problem. The algorithm will simply be too slow. Thankfully for us, we
can do this row by row instead.

First we need to get a concencus string from the matrix. Then we can find the sum of the hamming distance between pattern and motif.

Because Score(Motifs) corresponds to counting the lower case elements of Motifs column-by-column and d(Consensus(Motifs), Motifs) corresponds to counting these elements row-by-row,
we obtain that:

Score(Motifs) = d(Consensus(Motifs), Motifs).

This equation gives us an idea. Instead of searching for a collection of k-mers Motifs minimizing

Score(Motifs)

let's instead search for a potential consensus string Pattern minimizing

d(Pattern, Motifs)

among all possible k-mers Pattern and all possible choices of k-mers Motifs in Dna. This problem is equivalent to the Motif Finding Problem.


Motif(Pattern, Dna) is a collection of dna extracts that have the minimum hamming distance d(Pattern, Dna). If there are multiple - we just take the first one.

We now need to find a k-mer pattern that minimizes the d(Pattern, Dna) among all possible choices of k-mers. This is called the median string.

Notice that finding a median string requires solving a double minimization problem. We must find a k-mer Pattern that minimizes d(Pattern, Dna),
where this function is itself computed by taking a minimum over all choices of k-mers from each string in Dna.


Ok, so basically it goes like this:
First approach is - we go column by column and we compute the minimum at the end.
Second approach is - we calculate all possible k-mers first (basically permutations
or all k-mers from all strings of DNA) and then we go row by row to find the lowest minimum.

Why is the second approach better? Well, first approach, we have to go column by column and there can usually be thousands of columns (dna strings).
Second approach, we concatenate and check for eack k-mer but k-mers are usually below 20 so that makes it considerably faster.

First algorithm - O(n**t · k · t) t-strings, k-mer, n-length of strings.
Second algorithm - O(4**k · n · k · t) - which seems to be more favourable in our case.

Both algorithms should do the job though, just the second one should be more efficient.

The Median String Problem teaches an important lesson, which is that sometimes rethinking how a problem is formulated can lead to dramatic improvements in the runtime
required to solve it. In this case, our simple observation that Score(Motifs) could just as easily be computed row-by-row as column-by-column produced the faster
MedianString algorithm.

Unfortunately, this algorithm is still too slow and it takes half a day to execute. Maybe we could parallelize it using GPUs down the line?

PROBLEM: MEDIAN STRING - find the k-mer that is most conserved (has lowest score) among all dna strings using the new algorithm.

To solve the problem of finding a motif in DNA in a fast way, we may implement a Greedy Algorithm.
Greedy Algorithms are fast and provide an approximate solution. They attempt to select the most attractive path forward in
each iteration. For example, capturing the most valuable pieces in chess. (This does not always work.)

We imagine that we have a 4 sided dice and we attempt to roll it.
If we have a DNA ATCGGTC, we then check what is the probability of us rolling exactly this combination by multiplying the values that correspond to those nucleotides from the
dna probability matrix. For example 1*0.5*0.25*1 etc. Remember, this is the matrix we generated by the very first algorithm, which was then used to compute the entropy.
Here we use it to compute the probability of us rolling such a combination. High probability means we have a complete match (1 * 1 * 1). Low probability means we have a very
incomplete match. So, basically find the concensus string and then check probability for another string against it and its probability values for each nucleotide. (the matrix)

PROBLEM: STRING WITH HIGHEST PROBABILITY ACCORDING TO PROFILE OF CONCENCUS STRING - find the k-mer in the dna string that has the highest probability to occur (is nearest) to the
concensus string from which the profile was generated.


































