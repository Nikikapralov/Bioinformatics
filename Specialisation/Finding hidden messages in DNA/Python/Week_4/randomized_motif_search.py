"""
The randomized motif search works in the following way:
First choose random k-mers from each dna string as motifs.
Then, forever:
Generate the profile of those motifs (with pseudocounts!)
Get new most probable motifs from the profile and the provided dna - Check each k-mer in each string, score it and
choose the one with the highest probability.
Those are the new motifs.
Now check the score of such motifs. You can use hamming distance or entropy, as you like.
If the new score is higher return, if its lower - continue.

Return the motifs and their score. To get a good result, run the algorithm 1000 times (not the loop, the whole function)
and then choose set of motifs with the lowest score among those 1000 runs.
"""

import random
from Week_3.greedy_motif_search_with_pseudocounts import (score_k_mers_and_concencus_string,
                                                          build_probability_matrix_pseudocounts)
from Week_3.most_probable_motif_according_to_profile import get_most_probable_motif_according_to_probability_matrix

k_mer_length = 15
data = "TTCAACTCGCCAACAGACAAGGTATTCGCAATAAAAGAACAGTTGAAGACACAGGCGCCGCGACTTGGCCGATACCAGATGGCCTAAGCGCTTTCGAGAGTAAGATCGTTAGCTATCAGCCCCGGGAGCTTATCATGAGAGCCCATACACGGGTATCATGGGTGTTTTTCCGACTGATTCAACTCGCCAACA GACAAGGTATTCGCAATAAAAGAACAGTTGAAGACACAGGCGCCGCGACTTGGCCGATACCAGATGGCCTAAGCGCTTTCGAGAGTAAGATCGTTAGCTATCCTACGCCTGCAAGCAAGCCCCGGGAGCTTATCATGAGAGCCCATACACGGGTATCATGGGTGTTTTTCCGACTGATTCAACTCGCCAACA GCGAACAGTTTAAAACTGCAAGATGGAAGGCCGATGTCCGTATAAAACCGAACCGGACGGCGGTCGGCGATCGATGCGAGGCTTGGTGGTGTGAGCAAAATCTAAGTCAAAGCAGAAGGCTAAAAGTCGGAGAGTTGTCGGAAACGAACTCTGAATGTCCTCGATGGTGCTGTGAAGATGAAGAGGCGTTGG TGCATTGCTTGGTGGACGGTCGCTAAAAGGTCAAGCACAGCTTGTCCTGAAGGATTATTTTGATTTGTGGAGTTCCCGAGCGCATCTAGACACCAAATATCGAGGGCACTGCCTATGTTTATAATACAGCCCACCCGCGCCCAGAATTTTGGCCTCGTAATTATTGCCCCCTGTAGGCGCATGAATTATAAT GCAATCGAGAAAATATTTAGGACGAATTTCTTTTGATATCAACGGGGTTACCTCAGAGTGACCCCCGGATATAGGCAGGAGGGTGTTAGCACACCGATGGTGTTTCTAGGCCTGCAAGCAGCTTGTCACTCGTGATTGTGTCGTATTATAACTCATGAAAGGTGCCGTGCGGATAAAAAATTGCTACGATCG CGACGATAGTGGGCGGTACTTTGGCCTTTTATGTTGTTGTGCGTCGGACAAATGGATCGGATAGTAGGGGGGAGTTTTATTGTTCCATTTAGCGAATAAGTGTGATAATCGGATCGTCTCGAGTTACGGAGATAGCCCTTCAGATGGCGTGCTAAAACATTAAGCACGCATTTTCTCGTGTCAACTTGCGGC CTGTTTAATGAGTGCATGGCTAATACGCTGACACCGCCTAGGGGGAAGACGGGAACTGCAAGCACCGAGCATATGTGCAAATCGTCGACAGGGCAGTTGCCAAACCAGGCCCATTAGGCACTATCTTTTATGTCTCATACACTGAATTACGTCTCATGGCGCGCCTCGAAATGCGAAGCACAGGATCTTTCA GGTACGCACATTTTGTAGCTAAACTGTATGCGATCACCCTGGAAGGACCGATCACCCATCCGCCCCAACCTCCAGATAGTTTAACGATCCACTCTACCATGGAGGCAACGCTAATAACCTCTCTAATTAAGGGCTATAGCTGCTGCGACTGCAAGCACCGCTAATCTGGCGCTGGCTCAGGATCAAAGAATG GTCGATTTACACTCTGACCAGTGAGAGCCGCATGCCGGAATTTGGCGAATGTCCGTTGCCTTTGCTTATCTATGGAGCGAAGAACTAGCTAAATTAGCAAGCATAGGTCGGTGCGGAGGTGGGTTTCGCGGGTCGAGTCCGGTCGCGAGCCAGCATAGACGGGTGCTGGGTTGTGCCCAGTCTAGCGCCTTT ATCGAGATCCCCCAATAGTCCCCCTGTTGTGCGTAAACGTTAATACTCAAACATCGGTGTCTGTCCCACGGGTCGTTCGTTCCTACCAGCCCTTGAACTTCGCCACATCCCGACCATTCTGGGAATACTAAAACTGGCTGCACTCCCCGCCCACCGCAAAAAGTGTGCAATTTTCACACTAAGGGGCTTCGT AACAGAATGCGATAAATGGCCGGATCTTTCGACACTCTTTATGGGGACGGTCGTGTCACCCAACGCCTACCCGAAACACGTGGGCTAAACGAGCAAGCAAGTTGGCTTAAGACACTCAGCAAGTAGGACTACAAGGTGTTCCCACCGCTACCCACCGGGAGGCGTCAGAGTCTTCAGACGCAGCACGACACG TAGTCCCGGCTGCCTCATCCGCGCGTAGCAGGTCGGAGCTGCACTATAAGTATGCTTCGTTAAGGGCACCTCTTCGAAGAGGGCAACAGACGCTGGACTAACTTTTCATACCGAAGCTCCGGGAAATCAAACTCGCAGCGCACTAGCTTACTCTCGAAAAACTGCAAGCGACTCAGGAGTACTTTACACTGA ATGGACCGGGCATAAGATGGGCCTGGCGTATAGATGCCACTCGGAAAGCCTTAGCCCCCCAAGGTAAGGGTAGGAAGCGTGCGCTATCACTCACGGAAACTCGGTGAAAAAGACGGAATGGAAACTGCAAGCAGGAACCACTCCTGAGAATGAAGTCAGCACTAGATTGCGCCAGACTACCGCACTATGAAG CATATAATGTAAGGAAAGACGACAGTAATATTTTGATTTTCCCTCTTCCATCTAATGATGCAAGCAGTTCTAGCCTTCCTTTAAGTGGCGCGAGCGCGTGACAGAGGGATTTGACTGGTATTAAAGTGCACATGTAGCTTAGCCGGGAAGACAAAGCGTGTTTCGTTCGGTGCACGCAAGGTTATTAGTGTT AGGGTGCTCAAAGCCCGTAACAAAACCATTTCTACTCTGCACAGCCTCCCCCTCGTTTAGAACGTATCGGACTATCTCACCGGTGCTAAAAAACCAAGCAGCGCTCTATTGAGAATCAAAGCAGAGTACAAGACTATCCGTTACGAGCCAGTCTGTAATGGACATAAGCTTACCGTTTAGTACGAACATGTC AGGCGTGGAACTAAAACTGCAGAAACGAGAGTCTACGGAGACGTCTGGCGCCGTAGACTTTGGCACGAGCGTGGGGTTTCCGCCTTACGGTCGAATGGGGGGGCGAATCTAACAGATCGAGGCAACACTATGCTAATTCCTTATTGTCGCGAATTTGCCGTGGTTATTCATCCGGATTGTTGGACTTCTGTC TGGATAAAGGTCTTACTGCTAGTGCTCCCCTCTCTAAGGGTGCAAGCAAACAACACAGTTCGAGCTATATCAAGACGCTGGTAATCTCTCACGAGTTCCCGAGTGGTATGAATCAAGCACGGGGCGAGTCTCGGCGATAGAAAGGAGTTGGCTAATGAAATTGTAATCCGGAGCACTGAAGGCTTAGTTCCT TTTCTGCCCGTTTAGTGGGGGTATCCTATTGGTATAGATGTCCCCTGGGGCGCACGTTAACTCCGTTACGACCCGCCTGAGTTCCAACGTCAATCTAAAACTGCAATGTGGAGCAGCCGCAGTCCAGAGGAGTCCAGCTAGCCAAAATGGGATGTGAGAGTCTCCCTAAACAACGTTCGGGGTAGGCTCACT GAATAAGAATTCTCCTACCAGCCCCGATGCCAAAAGCGCATTATTAGGCAGGTGGTCTATCCGCAATTCCGGTTGCTTACGGTTATGTGAATCAGATAGGGAACATACTTACACGCAGCTACCTCACACCAAGACTAATCAAAGGATCAAAAGTCATCCGGTTCCGCTAAAACTCTGAGCACCTTCGCTCTG ATTCTGTGGCTCCCGGGTCAGTGTCGTCTACGCTCAAACTCCAATGACTCAGTACGGAAGCAAAATCGCGAGTCAGTGCGACATCACCTGCTACACCATCTCAAATGTGAATTTTGCCGTGTGAGATACATACTGGCTTGGGCGGTGATCGGATCAGCTTATCACGCGAGGTCCGCTAAAACTGCCGTCAAA"
data = data.split(" ")


def randomized_motif_search(data, k_mer_length):
    motifs = get_random_k_mers(data, k_mer_length) # Get the random motifs.
    best_motifs = motifs
    concensus_string, best_score = score_k_mers_and_concencus_string(best_motifs) # Get the score of those motifs.
    while True:
        probability_profile_matrix = build_probability_matrix_pseudocounts(motifs) # Build the matrix.
        motifs = new_most_probable_motifs(data, probability_profile_matrix, k_mer_length) # Find new motifs that are most probable.
        concensus_string, current_score = score_k_mers_and_concencus_string(motifs) # Compute the score of the new motifs.
        if current_score < best_score: # If score is lower, continue. If higher, stop.
            best_motifs = motifs
            best_score = current_score
        else:
            return best_motifs, best_score



def get_random_k_mers(data, k_mer_length):
    """
    Generate random k-mers. We need to generate just the start of the string,
    then we can simply do start + k_mer_length as our newest k_mer.
    """
    k_mers = []
    maximum_start_index = len(data[0]) - k_mer_length # +1 only when used in a for range loop since loop is exclusive

    for dna_entry in data:
        k_mer_start = random.randint(0, maximum_start_index)
        k_mer = dna_entry[k_mer_start:k_mer_start+k_mer_length]
        k_mers.append(k_mer)

    return k_mers


def new_most_probable_motifs(dna_strings, probability_matrix, k_mer_length):
    """
    Use the function from week 3, but modify it to be ran on each dna string, instead of just one.
    """
    motifs = []
    for dna_string in dna_strings:
        motif = get_most_probable_motif_according_to_probability_matrix(dna_string, k_mer_length, probability_matrix)
        motifs.append(motif[0])
    return motifs

#  We have to run the algorithm a 1000 times and then get the result with the lowest score.

def solution(data, k_mer_length):
    results = []
    for i in range(10**3):
        results.append(randomized_motif_search(data, k_mer_length))
    return sorted(results, key=lambda x: x[1])

print(" ".join(solution(data, k_mer_length)[0][0]))